\def\year{2020}\relax
%File: formatting-instruction.tex
\documentclass[letterpaper]{article} % DO NOT CHANGE THIS
\usepackage{aaai20}  % DO NOT CHANGE THIS
\usepackage{times}  % DO NOT CHANGE THIS
\usepackage{helvet} % DO NOT CHANGE THIS
\usepackage{courier}  % DO NOT CHANGE THIS
\usepackage[hyphens]{url}  % DO NOT CHANGE THIS
\usepackage{graphicx} % DO NOT CHANGE THIS
\urlstyle{rm} % DO NOT CHANGE THIS
\def\UrlFont{\rm}  % DO NOT CHANGE THIS
\usepackage{graphicx}  % DO NOT CHANGE THIS
\frenchspacing  % DO NOT CHANGE THIS
\setlength{\pdfpagewidth}{8.5in}  % DO NOT CHANGE THIS
\setlength{\pdfpageheight}{11in}  % DO NOT CHANGE THIS
\usepackage{listings}
\usepackage{xcolor}
\usepackage{multicol}

% Colors

\definecolor{potcolor}{RGB}{0,62,90}

%\nocopyright
%PDF Info Is REQUIRED.
% For /Author, add all authors within the parentheses, separated by commas. No accents or commands.
% For /Title, add Title in Mixed Case. No accents or commands. Retain the parentheses.
 \pdfinfo{
/Title (Course Project Milestone 4 - Individual Project Report)
/Author (Claudio Rodriguez)
} %Leave this	
% /Title ()
% Put your actual complete title (no codes, scripts, shortcuts, or LaTeX commands) within the parentheses in mixed case
% Leave the space between \Title and the beginning parenthesis alone
% /Author ()
% Put your actual complete list of authors (no codes, scripts, shortcuts, or LaTeX commands) within the parentheses in mixed case. 
% Each author should be only by a comma. If the name contains accents, remove them. If there are any LaTeX commands, 
% remove them. 

% DISALLOWED PACKAGES
% \usepackage{authblk} -- This package is specifically forbidden
% \usepackage{balance} -- This package is specifically forbidden
% \usepackage{caption} -- This package is specifically forbidden
% \usepackage{color (if used in text)
% \usepackage{CJK} -- This package is specifically forbidden
% \usepackage{float} -- This package is specifically forbidden
% \usepackage{flushend} -- This package is specifically forbidden
% \usepackage{fontenc} -- This package is specifically forbidden
% \usepackage{fullpage} -- This package is specifically forbidden
% \usepackage{geometry} -- This package is specifically forbidden
% \usepackage{grffile} -- This package is specifically forbidden
% \usepackage{hyperref} -- This package is specifically forbidden
% \usepackage{navigator} -- This package is specifically forbidden
% (or any other package that embeds links such as navigator or hyperref)
% \indentfirst} -- This package is specifically forbidden
% \layout} -- This package is specifically forbidden
% \multicol} -- This package is specifically forbidden
% \nameref} -- This package is specifically forbidden
% \natbib} -- This package is specifically forbidden -- use the following workaround:
% \usepackage{savetrees} -- This package is specifically forbidden
% \usepackage{setspace} -- This package is specifically forbidden
% \usepackage{stfloats} -- This package is specifically forbidden
% \usepackage{tabu} -- This package is specifically forbidden
% \usepackage{titlesec} -- This package is specifically forbidden
% \usepackage{tocbibind} -- This package is specifically forbidden
% \usepackage{ulem} -- This package is specifically forbidden
% \usepackage{wrapfig} -- This package is specifically forbidden
% DISALLOWED COMMANDS
% \nocopyright -- Your paper will not be published if you use this command
% \addtolength -- This command may not be used
% \balance -- This command may not be used
% \baselinestretch -- Your paper will not be published if you use this command
% \clearpage -- No page breaks of any kind may be used for the final version of your paper
% \columnsep -- This command may not be used
% \newpage -- No page breaks of any kind may be used for the final version of your paper
% \pagebreak -- No page breaks of any kind may be used for the final version of your paperr
% \pagestyle -- This command may not be used
% \tiny -- This is not an acceptable font size.
% \vspace{- -- No negative value may be used in proximity of a caption, figure, table, section, subsection, subsubsection, or reference
% \vskip{- -- No negative value may be used to alter spacing above or below a caption, figure, table, section, subsection, subsubsection, or reference

\setcounter{secnumdepth}{0} %May be changed to 1 or 2 if section numbers are desired.


% Listings

\lstset{numbers=none,numberblanklines=false,columns=fullflexible,basicstyle=\ttfamily,linewidth=\columnwidth,breaklines=true}

\newcommand{\CodeSymbol}[1]{\bfseries\textcolor{violet}{#1}}   % Code associated to defining styles
\newcommand{\InitColor}[1]{\bfseries\textcolor{red}{#1}}   % Code associated to defining styles
\newcommand{\PairColor}[1]{\bfseries\textcolor{blue}{#1}}   % Code associated to defining styles

\definecolor{codegray}{gray}{0.95}
\definecolor{commentgray}{gray}{0.35}

\makeatletter

\lstdefinelanguage{clingo}{%
  basicstyle=\ttfamily,%
  backgroundcolor=\color{codegray},
  showstringspaces=false,%
  alsoletter=0123456789,%
  keywords=[3]{&,&dom,&sum,&diff,&show},%
  morecomment=[l]{\#\ },%
  morecomment=[l]{\%\ },%
  morestring=[b]",%
  stringstyle={\itshape},%
  commentstyle={\color{commentgray}},%
  literate={init}{{\InitColor{init}}}1
           {pair}{{\PairColor{pair}}}1
           {\#const}{{\CodeSymbol{\#const }}}1
           {\#show}{{\CodeSymbol{\#show }}}1
           {\#minimize}{{\CodeSymbol{\#minimize }}}1
           {\#base}{{\CodeSymbol{\#base }}}1
           {\#theory}{{\CodeSymbol{\#theory }}}1
           {\#count}{{\CodeSymbol{\#count }}}1
           {\#external}{{\CodeSymbol{\#external }}}1
           {\#program}{{\CodeSymbol{\#program }}}1
           {\#script}{{\CodeSymbol{\#script }}}1
           {\#end}{{\CodeSymbol{\#end }}}1
           {\#heuristic}{{\CodeSymbol{\#heuristic }}}1
           {\#edge}{{\CodeSymbol{\#edge }}}1
           {\#project}{{\CodeSymbol{\#project }}}1
           {\#show}{{\CodeSymbol{\#show }}}1
           {\#sum}{{\CodeSymbol{\#sum }}}1%
}

\newcommand\opstyle{\CodeSymbol} % <--- customise operator style here

% Hook into listings
\lst@AddToHook{OutputOther}{\ProcessOther@silmeth}

% helper macro
\newcommand\ProcessOther@silmeth
{%
  \ifnum\lst@mode=\lst@Pmode%     % If we're in `Processing' mode...
    \def\lst@thestyle{\opstyle}%  % ... redefine the style locally
  \fi%
}

\makeatother

\newcommand{\Sim}{{\raise.17ex\hbox{\ensuremath{\scriptstyle\sim}}}}



% The file aaai20.sty is the style file for AAAI Press 
% proceedings, working notes, and technical reports.
%
\setlength\titlebox{2.5in} % If your paper contains an overfull \vbox too high warning at the beginning of the document, use this
% command to correct it. You may not alter the value below 2.5 in
\title{Individual Progress Report\\
Course Project Milestone 3\\
CSE 579: Knowledge Representation and Reasoning}
%Your title must be in mixed case, not sentence case. 
% That means all verbs (including short verbs like be, is, using,and go), 
% nouns, adverbs, adjectives should be capitalized, including both words in hyphenated terms, while
% articles, conjunctions, and prepositions are lower case unless they
% directly follow a colon or long dash
\author{ \\
Written by\\
\Large \textbf{Claudio Rodriguez Rodriguez} \\ 
Arizona State University}

\begin{document}

\maketitle

\section{Problem Statement}

CSE579 includes theory on Answer Set Programming using Clingo to develop solutions for real-world problems. In this project, we will be using these tools to craft a Solution for the Automated Warehouse Scenario from the ASP Challenge 2019. The description of the Scenario is as follows:

\begin{quotation}
A simplified version of automated planning done in Amazon warehouses, this project focuses on an automated warehouse in which robots deliver products to picking stations to fulï¬ll orders. A warehouse is represented as a rectangular grid, and the robots can move horizontally or vertically between adjacent cells.\cite{cse579:CourseProject}
\end{quotation}

The overall goal is to fulfill orders presented in the source files from the ASP Challenge 2019 while minimizing the time to perform their actions. We will emphasize representing the problem in Clingo using the lectures relating to Transition Systems and Representing Actions.


\section{Project Background}

There was no previous knowledge of ASP besides that learned during Knowledge Representation and Reasoning. The base for working on the project was Videos related to The Monkey and Bananas Problem in ASP\cite{cse579:CourseMonkeyAndBananasPart1}\cite{cse579:CourseMonkeyAndBananasPart2} and Block World in ASP\cite{cse579:CourseBlocksWorld}. To craft the solution, we used a similar approach to these problems.

Testability was a challenge until the Class mentioned Asprilo, which per their website is:

\begin{quotation}
"asprilo" is a benchmarking framework to study typical scenarios in intra-logistics and warehouse automation with multiple mobile robots. 
Asprilo contains multiple tools, but the one that we used during the project is the Visualizer.\cite{cse579:asprilo}
\end{quotation}

The Visualizer takes input and output very similar to the Automation Warehouse problem. We label input as `init` and output as `occurs`. 

\begin{lstlisting}[numbers=none,language=clingo]
  init(object(order,3),value(line,pair(4,1))).
  occurs(object(robot,2),action(move,(-1,0)),0).
\end{lstlisting}

\section{Approach to Solution}

The first part of developing a solution was designing the following:

\begin{itemize}
  \item Whether Robot has Shelf. \texttt{hasShelf}
  \item Whether Shelf has Product. \texttt{hasProduct}
  \item Locations of: Node, Highways, Shelf, Picking Stations, Robots, Products, and Orders
\end{itemize}

And we took the structure of the code based on the problems observed in the class by breaking it down into the following sections:

\begin{enumerate}
  \item Sort and object declarations (\textit{fluents}).
  \item State constraints (\textit{actions}).
  \item Effect and preconditions of actions.
  \item Action constraints.
  \item Domain independent axioms.
\end{enumerate}

And part of the design was to identify all the constraints:

\begin{itemize}
  \item One action per timestep.
  \item During a timestep, a robot will do one of the following: \texttt{move}, \texttt{pickUpShelf}, \texttt{putDownShelf}, \texttt{remainIdle}.
  \item Robot can pick only shelf at a time.
  \item Robot needs to be on the same location as the shelf to pick it up.
  \item Shelves and Picking Stations can't be placed on highways.
  \item We can't move a shelf into a cell that has another shelf. 
\end{itemize}

Our actions looked as follows:

\begin{lstlisting}[numbers=none,language=clingo]
% Effect of delivering a product
% Remove from Goal Units
goal(OrderId, NodeId, ProductId, GoalUnits - FromShelf, T+1) :-
 deliver(RobotId, OrderId, ShelfId, ProductId, FromShelf, T),
 goal(OrderId, NodeId, ProductId, GoalUnits, T).
  
% Remove from Shelf Units
onShelf(ProductId, ShelfId, ShelfUnits - DeliveredUnits, T+1) :- 
 deliver(RobotId, OrderId, ShelfId, ProductId, DeliveredUnits, T),
 onShelf(ProductId, ShelfId, ShelfUnits, T).
 
% Make sure at the end we have no 
% Products left on the Order
:- not goal(OrderId, _, ProductId, 0, maxstep), goal(OrderId, _, ProductId, _, 0).
\end{lstlisting}
  

After transforming the input into state objects, the challenge was identifying the goal state. We determined that two inputs in the original problem contained the goal state. We define the goal state as similar to a factory, where the products reach transportation and then get subtracted from the inventory altogether. This model means that we remove Products from both the Shelf and the Order once we delivered them.

\begin{lstlisting}[numbers=none,language=clingo]
% Effect of delivering a product
% Remove from Goal Units
goal(OrderId, NodeId, ProductId, GoalUnits - FromShelf, T+1) :-
  deliver(RobotId, OrderId, ShelfId, ProductId, FromShelf, T),
  goal(OrderId, NodeId, ProductId, GoalUnits, T).

% Remove from Shelf Units
onShelf(ProductId, ShelfId, ShelfUnits - DeliveredUnits, T+1) :- 
  deliver(RobotId, OrderId, ShelfId, ProductId, DeliveredUnits, T),
  onShelf(ProductId, ShelfId, ShelfUnits, T).

% Make sure at the end we have no 
% Products left on the Order
:- not goal(OrderId, _, ProductId, 0, maxstep), goal(OrderId, _, ProductId, _, 0).
\end{lstlisting}

Afterward, it was a matter of iterating until reaching the correct result. Testing proved difficult until we used Asprilo Visualizer.  There was a functional test for every instance and then a final integration test that started with the following command:

\begin{lstlisting}[numbers=none]
clingo i1.lp m.lp -c m=13 0 > o1.lp & ^
clingo i2.lp m.lp -c m=11 0 > o2.lp & ^
clingo i3.lp m.lp -c m=7 0 > o3.lp & ^
clingo i4.lp m.lp -c m=10 0 > o4.lp & ^
clingo i5.lp m.lp -c m=6 0 > o5.lp
\end{lstlisting}

\section{Main Results and Analysis}

An interesting detail that appeared during development was the following:

\begin{lstlisting}[numbers=none,language=clingo]
deliver(RobotId, OrderId, with(ShelfId, ProductId, Units), T) : 
  orderAt(OrderId, object(node, NodeId), contains(ProductId, _), T),
  productOn(ProductId, object(shelf, ShelfId), with(quantity, Units), T)
\end{lstlisting}

This "deliver" action created a challenge for clingo and increased development time by a few seconds. By expanding the set of possibilities, we saw a reduction in speed that considerably decreased the clock time. We increased the set using the following:

\begin{lstlisting}[numbers=none,language=clingo]
deliver(RobotId, OrderId, with(ShelfId, ProductId, UnitsToDeliver), T) : 
  orderAt(OrderId, object(node, NodeId), contains(ProductId, _), T),
  productOn(ProductId, object(shelf, ShelfId), with(quantity, Units), T), 
  UnitsToDeliver=1..Units
\end{lstlisting}

Thanks to Asprilo, we found out critical bugs that were easy to hide because the Actions were not affected by the new constraints. The first one was that our Robots were swapping places, and the more noticeable one, the robot was moving through Nodes that contained a shelf. 

Without the constraint of "Robot carrying a Shelf can't move through another Node with a Shelf," there was no coordination between the robots. This critical rule looks like the following:

\begin{lstlisting}[numbers=none,language=clingo]
:- onNode(shelf(ShelfId1), NewNodeId, T+1),
  robotMove(RobotId, move(DX, DY), T),
  onRobot(ShelfId2, RobotId, T),
  onNode(robot(RobotId), NodeId, T),
  nodeAt(NodeId, pair(X, Y)),
  nodeAt(NewNodeId, pair(X+DX, Y+DY)),
  ShelfId1!=ShelfId2.
\end{lstlisting}


Optimization was relatively simple once we wrote all outputs using the following:

\begin{lstlisting}[numbers=none,language=clingo]
totalTimestamp(N) :- N = #count{ T : occurs(O, A, T) } .
#minimize{ N : totalTimestamp(N) } .
\end{lstlisting}

And the output was the following which gave us what we needed to open it with asprilo:

\begin{lstlisting}[numbers=none,language=clingo]
#show init/2.
#show occurs/3.
\end{lstlisting}

The main difference between the output in the project statement\cite{cse579:CourseProject} and asprilo\cite{cse579:asprilo} is the addition of an `action` keyword.

\begin{table}[h!]
  \begin{center}
    \caption{Main Results.}
    \label{tab:table1}
    \begin{tabular}{l|c|r} % <-- Alignments: 1st column left, 2nd middle and 3rd right, with vertical lines in between
      \textbf{Problem} & \textbf{Optimum N} & \textbf{CPU}\\
      \textbf{Instance} & \textbf{Steps} & \textbf{Time}\\
      \hline
      1 & 13 & 1.266s\\
      2 & 11 & 0.313s\\
      3 & 7 & 0.078s\\
      3 & 10 & 0.250s\\
      3 & 6 & 0.063s\\
    \end{tabular}
  \end{center}
\end{table}

\section{Conclusion}

I would have enjoyed a little more time delivering the project. I also found out about Asprilo a bit too late. My first attempt was to make a script to do that for me, but there was not enough time capacity. I thoroughly enjoyed making sure all the constraints were there once I had a way to test it. Asprilo provides a video that allowed me to verify my restrictions. 

I am proud of the code I wrote in ASP, and I can't wait to delve deeper into it. The main thing I wish I had time for was to test my solution against more oversized test cases. In the end, I started removing constraints such as "No two shelves per Node," with no consequence. This finding leads me to believe I have redundant rules in my code.


\section {Oppotunities for future work}

For future work, I would like to apply what I learned on business rules at work. ASP is very concise and allows for easy-to-read code. This code is suitable for code that I need to share with Management. I would also like to explore more into OWL ontologies and see how I can leverage ASP with OWL.

There are other challenges to exploring, such as interop with an ASP language such as clingo and other languages, such as C\#. But today, we can execute clingo quickly using a Function in the Cloud such as Azure Functions. This quick implementation would allow us to have a simple way to send input to an ASP Model. 



\bibliography{cse579}
\bibliographystyle{aaai}

\onecolumn % <==========================================================
\section {Appendix}
 % <================================================

 \begin{lstlisting}[numbers=none,language=clingo]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% sort and object declaration
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
move(0, 1;0, -1;-1, 0;1, 0).

nodeAt(NodeId, pair(X, Y)) :- init(object(node, NodeId), value(at, pair(X, Y))).
pair(X, Y) :- init(object(node, NodeId), value(at, pair(X, Y))).
node(NodeId) :- init(object(node, NodeId), value(at, pair(X, Y))).

highway(NodeId) :- init(object(highway, NodeId), value(at, pair(X, Y))).

onNode(pickingStation(PSId), NodeId) :- init(object(pickingStation, PSId), value(at, pair(X, Y))), init(object(node, NodeId), value(at, pair(X, Y))).
pickingStation(PSId) :- init(object(pickingStation, PSId), value(at, pair(X, Y))), init(object(node, NodeId), value(at, pair(X, Y))).

onNode(robot(RobotId), NodeId, 0) :- init(object(robot, RobotId), value(at, pair(X, Y))), nodeAt(NodeId, pair(X, Y)).
robot(RobotId) :- init(object(robot, RobotId), value(at, pair(X, Y))).

onNode(shelf(ShelfId), NodeId, 0) :- init(object(shelf, ShelfId), value(at, pair(X, Y))), nodeAt(NodeId, pair(X, Y)).
shelf(ShelfId) :- init(object(shelf, ShelfId), value(at, pair(X, Y))).

onShelf(ProductId, ShelfId, Units, 0) :- init(object(product, ProductId), value(on, pair(ShelfId, Units))).
product(ProductId) :- init(object(product, ProductId), value(on, pair(ShelfId, Units))).

goal(OrderId, NodeId, ProductId, Units, 0) :- 
  init(object(order, OrderId), value(pickingStation, PSId)),
  onNode(pickingStation(PSId), NodeId),
  init(object(order, OrderId), value(line, pair(ProductId, Units))).
order(OrderId) :- init(object(order, OrderId), value(pickingStation, PSId)).

numberOfColumns(NR) :- NR=#count{ X:init(object(node, I), value(at, pair(X, Y))) }.
numberOfRows(NC) :- NC=#count{ Y:init(object(node, I), value(at, pair(X, Y))) }.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Actions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

{ robotMove(RobotId, move(DX, DY), T) : move(DX, DY) } 1 :- robot(RobotId), T=0..maxstep-1.
{ pickUp(RobotId, ShelfId, T) : shelf(ShelfId) } 1 :- robot(RobotId), T=0..maxstep-1.
{ putDown(RobotId, ShelfId, T) : shelf(ShelfId) } 1 :- robot(RobotId), T=0..maxstep-1.

% Goal units are different from onShelf units
{ deliver(RobotId, OrderId, ShelfId, ProductId, UnitsToDeliver, T) : 
    goal(OrderId, NodeId, ProductId, GoalUnits, T), 
    onShelf(ProductId, ShelfId, Units, T), 
    UnitsToDeliver=1..Units
} 1 :- robot(RobotId), T=0..maxstep-1.

%converting them to the necessary output
occurs(object(robot, RobotId), action(move, (DX, DY)), T) :- robotMove(RobotId, move(DX, DY), T).

occurs(object(robot, RobotId), action(pickup, ()), T) :- pickUp(RobotId, _, T).

occurs(object(robot, RobotId), action(putdown, ()), T) :- putDown(RobotId, _, T).

occurs(object(robot, RobotId), action(deliver, (OrderId, ProductId, Units)), T) :- deliver(RobotId, OrderId, ShelfId, ProductId, Units, T).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% action constraints
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Two actions cannot occur at the same time
:- occurs(object(robot, RobotId), A1, T), occurs(object(robot, RobotId), A2, T), A1!=A2.

% Limit movement of robot
:- onNode(robot(RobotId), NodeId, T), 
    robotMove(RobotId, move(DX, DY), T),
    nodeAt(NodeId, pair(X, Y)), 
    X + DX < 1.
:- onNode(robot(RobotId), NodeId, T), 
    robotMove(RobotId, move(DX, DY), T),
    nodeAt(NodeId, pair(X, Y)), 
    Y + DY<1.
:- onNode(robot(RobotId), NodeId, T), 
    robotMove(RobotId, move(DX, DY), T),
    nodeAt(NodeId, pair(X, Y)), 
    X + DX > NC,
    numberOfColumns(NC).
:- onNode(robot(RobotId), NodeId, T), 
    robotMove(RobotId, move(DX, DY), T),
    nodeAt(NodeId, pair(X, Y)), 
    Y + DY > NR,
    numberOfRows(NR).

% However, a robot that carries a shelf does not fit under another shelf anymore, 
% so that shelves may need to be moved out of the way first.
:- onNode(shelf(ShelfId1), NewNodeId, T+1),
    robotMove(RobotId, move(DX, DY), T),
    onRobot(ShelfId2, RobotId, T),
    onNode(robot(RobotId), NodeId, T),
    nodeAt(NodeId, pair(X, Y)),
    nodeAt(NewNodeId, pair(X+DX, Y+DY)),
    ShelfId1!=ShelfId2.

% A shelf cant be picked up by 2 robots
:- pickUp(RobotId1, ShelfId, T), pickUp(RobotId2, ShelfId, T), RobotId1!=RobotId2.

% A robot cannot pickup a shelf if it already has one.
:- pickUp(RobotId, ShelfId1, T), onRobot(ShelfId2, RobotId, T).

% A robot cannot pickup a shelf a shelf is already on a robot
:- pickUp(RobotId1, ShelfId, T), onRobot(ShelfId, RobotId2, T).

% A robot can pick up shelf only if it is on the node containing that shelf
:- pickUp(RobotId, ShelfId, T), onNode(shelf(ShelfId), NodeId, T), not onNode(robot(RobotId), NodeId, T). 

% A robot can put down a shelf only if it has one.
:- putDown(RobotId, ShelfId, T), not onRobot(ShelfId, RobotId, T).

% A robot cannot putdown a shelf on a highway
:- putDown(RobotId, ShelfId, T), onNode(robot(RobotId), NodeId, T), highway(NodeId). 

% Can only deliver if robot is on picking station
:- deliver(RobotId, OrderId, _, ProductId, _, T), goal(OrderId, NodeId, ProductId, _, T), not onNode(robot(RobotId), NodeId, T).

% Can only deliver if robot has the shelf containing product
:- deliver(RobotId, OrderId, ShelfId, ProductId, _, T), onShelf(ProductId, ShelfId, _, T), not onRobot(ShelfId, RobotId, T).

% Cannot deliver more quantities than the order.
:- deliver(RobotId, OrderId, ShelfId, ProductId, ShelfUnits, T),
    goal(OrderId, NodeId, ProductId, GoalUnits, T),
    ShelfUnits > GoalUnits.

% Cannot deliver more quantities than the product.
:- deliver(RobotId, OrderId, ShelfId, ProductId, ShelfUnits, T),
    onShelf(ProductId, ShelfId, GoalUnits, T), ShelfUnits > GoalUnits.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% state constraints
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Picking Station cannot be a highway
:- onNode(pickingStation(_), NodeId), highway(NodeId).

% Shelf cannot be on a highway.
:- onNode(shelf(ShelfId), NodeId, _), highway(NodeId).

% Robots cant swap places
:- onNode(robot(RobotId1), NodeId1, T),
    onNode(robot(RobotId1), NodeId2, T+1),
    onNode(robot(RobotId2), NodeId2, T),
    onNode(robot(RobotId2), NodeId1, T+1),
    RobotId1!=RobotId2.

% 1 Shelf per robot 
:- onRobot(ShelfId, RobotId1, T), onRobot(ShelfId, RobotId2, T), RobotId1!=RobotId2.

% 1 Shelf per node
:- onNode(shelf(ShelfId), NodeId1, T), onNode(shelf(ShelfId), NodeId2, T), NodeId1!=NodeId2.

% No robot on 2 nodes
:- onNode(robot(RobotId), NodeId1, T), onNode(robot(RobotId), NodeId2, T), NodeId1!=NodeId2.

% No 2 robots on the same node
:- onNode(robot(RobotId1), NodeId, T), onNode(robot(RobotId2), NodeId, T), RobotId1!=RobotId2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% action effects
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Effect of picking up a shelf
onRobot(ShelfId, RobotId, T+1) :- pickUp(RobotId, ShelfId, T), onNode(shelf(ShelfId), NodeId, T), onNode(robot(RobotId), NodeId, T).

%Effect of putting down a shelf
onNode(shelf(ShelfId), NodeId, T+1) :- putDown(RobotId, ShelfId, T), onRobot(ShelfId, RobotId, T), onNode(robot(RobotId), NodeId, T).

% Effect of delivering a product
% Remove from Goal Units
goal(OrderId, NodeId, ProductId, GoalUnits - FromShelf, T+1) :-
  deliver(RobotId, OrderId, ShelfId, ProductId, FromShelf, T),
  goal(OrderId, NodeId, ProductId, GoalUnits, T).

% Remove from Shelf Units
onShelf(ProductId, ShelfId, ShelfUnits - DeliveredUnits, T+1) :- 
  deliver(RobotId, OrderId, ShelfId, ProductId, DeliveredUnits, T),
  onShelf(ProductId, ShelfId, ShelfUnits, T).

% Effect of moving a robot
onNode(robot(RobotId), NewNodeId, T+1) :-
  onNode(robot(RobotId), NodeId, T),
  nodeAt(NodeId, pair(X, Y)),
  nodeAt(NewNodeId, pair(X+DX, Y+DY)),
  robotMove(RobotId, move(DX, DY), T).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% domain independent axioms
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

onNode(robot(RobotId), NodeId, T+1) :- onNode(robot(RobotId), NodeId, T), not robotMove(RobotId, move(_, _), T), T<maxstep.

onNode(shelf(ShelfId), NodeId, T+1) :- onNode(shelf(ShelfId), NodeId, T), not pickUp(_, ShelfId, T), T<maxstep.

onRobot(ShelfId, RobotId, T+1) :- onRobot(ShelfId, RobotId, T), not putDown(RobotId, ShelfId, T), T<maxstep.

goal(OrderId, NodeId, ProductId, Units, T+1) :- 
  goal(OrderId, NodeId, ProductId, GoalUnits, T),
  onShelf(ProductId, ShelfId, Units, T),
  not deliver(_, OrderId, ShelfId, ProductId, _, T),
  T < maxstep.

onShelf(ProductId, ShelfId, Units, T+1) :- onShelf(ProductId, ShelfId, Units, T), not deliver(_, _, ShelfId, ProductId, _, T), T < maxstep.

% On MaxStep Goal Units must be 0 to be Fullfilled
:- not goal(OrderId, _, ProductId, 0, maxstep), goal(OrderId, _, ProductId, _, 0).

totalTimestamp(N) :- N = #count{ T : occurs(O, A, T) } .
#minimize{ N : totalTimestamp(N) } .

#show init/2.
#show occurs/3.
  \end{lstlisting}
\

\end{document}
